import { Link, Construction } from '@brillout/docpress'
import { UiFrameworkExtension } from '../../components'

<Link href="#flexible" /><br/>
<Link href="#dependable" /><br/>

<Construction>This page is work-in-progress and part of our <Link href="/releases/2024-06#new-marketing">ongoing work to overhaul Vike's marketing</Link>.</Construction>


## Flexible

Vike is designed to be flexible, so that it can fit your needs.

### Architectural freedom

With Vike you have architectural freedom and you can choose any deployment strategy, any backend, any data-fetching tool, any UI library, and any render mode.

> For example, you can choose any:
> - UI framework: **React**, **Vue**, **Solid**, ...
> - Render mode: **SSR**, **SSG**, **SPA**, **MPA**, ...
> - Data fetching.
>   - <Link href="/RPC">**RPC**</Link>: tRPC, Telefunc, ...
>   - **GraphQL**: Apollo, Relay, ...
>   - **REST**: TanStack Query, `fetch()`, ...
> - Deployment strategy.
>   - **Static host**, using <Link href="/pre-rendering">pre-rendering (aka SSG)</Link> with Netlify, GitHub Pages, ...
>   - **Server**: AWS EC2, DigitalOcean, ...
>   - **Serverless**: Vercel, AWS Lambda, ...
>   - **Edge**: Cloudflare Workers, Deno Deploy, ...
> - Backend.
>   - **Zero backend**: SSG, Firebase, Cloudflare, ...
>   - **JavaScript server**: Express.js, Hono, Deno, Bun, Fastify, ...
>   - **Non-JavaScript server**: Java, Ruby on Rails, Laravel, ...

> If you are curious, see <Link href="/architecture" /> for an explanation on why Vike's design is flexible.

Architectural freedom also enables you to continuously adapt your stack to needs that evolve as you grow.

> For example:
> - You don't know whether to use SSR, SPA, or SSG? Start with your best guess and progressively switch as it becomes clearer which fits better.
> - You aren't sure whether to use React, Vue, or Solid? Start with your intuition and reasses your choice as you gain experience. You can switch and migrate <Link href="/config#powerful:~:text=different%20rendering%20strategies%20for%20the%20same%20app">in a progressive fashion</Link>.
> - Start with <Link href="/RPC">RPC</Link>, then progressively switch to GraphQL if/when the need arises.
> - Start a JavaScript backend then, if the need arises, progressively switch to a highly-scalable backend such as Elixir.

### Eject, for fully custom integrations

Use <Link href="/extensions">Vike extensions</Link> for a quick start and, later, if an extension doesn't integrate a tool exactly as you need, you can eject it and fully customize the integration.

If you were to eject all extensions, then you would have complete control over how tools integrate with Vike and with each other. We call this <Link href="/optional-control">Optional Control</Link>.

You get the best of both worlds: a quick start without compromising on flexibility.

> For example, you can use <UiFrameworkExtension name /> to get a quick start like a regular framework (Next.js/Nuxt/...) while, later, you can eject and fully customize the React/Vue/Solid integration.

### Less blockers, by caring and prioritization

Vike is flexible not only by design but also by prioritization: we focus on the long tail of details and features that unblock users. It's often the small details that decide whether you can achieve your goal.

> For example, with Vike, you have <Link href="/data#environment">fine-grained control over where data is fetched from</Link>: the server-side, client-side, or both. It's a small but essential feature for Vike's first-class support of both:
> - <Link href="/pre-rendering">SSG</Link> apps, which usually lean more on the client.
> - SSR apps, which usually lean more on the server.

<Link href="/faq#i-can-t-achieve-what-i-want-can-i-get-help">We encourage users to reach out</Link> if they run into a blocker caused by Vike. It's also helpful for us, as we prioritize resolving blockers (ideally by design and at least by providing help). The more use cases we know about, the better.

A common source of blockers are bugs, and that's why we [systematically and quickly fix bugs](https://github.com/vikejs/vike/issues?q=label%3A%22bug+%3Aboom%3A%22+) &mdash; usually under 24 hours.


## Dependable

Vike's architecture provides a uniquely robust foundation.

### Stable core, for maximum stability (and innovation)

Vike, essentially, is a core that is extensible, robust, and stable.

This sturdy core provides stability and fosters innovation, enabling a diverse ecosystem of <Link href="/extensions">Vike extensions</Link>.

Prominent extensions focus on supporting businesses in a stable and long-term fashion, while cutting-edge extensions push the envelope on performance and DX.

Only carefully selected and battle-tested new techniques make it to stable extensions.

> For example, we're experimenting with RSC (React Server Components) in a separate extension `vike-react-rsc`. This allows us to quickly iterate without disrupting `vike-react` users.
>
> After (and only if) we're confident about RSC, we will release it as `vike-react` and rename the current extension to `vike-react-classic` while maintaining both extensions for the foreseeable future.

### Use new technology at your own pace

Stop using a framework that forces you to use the bleeding edge. Use new technologies at your own pace, and only if you see fit.

Vike's dual approach of having stable as well as cutting-edge extensions gives you choice.

> While some are early adopters, many prefer stability: not every company has the capacity to experiment with new and unstable technology.
>
> For companies that like exploring the technological frontier, Vike's <Link href="/optional-control">Optional Control</Link> and cutting-edge extensions are a treasure trove.

### By engineers, for engineers

Vike is a community-driven and independent project 100% led by engineers.

We don't serve the interests of any unrelated business, we serve the interests of our users. This makes a profound and fundamental difference.

> For example, we also care about the "old-school" setup of having a Java/PHP/Ruby backend with a decoupled statically deployed frontend. Other frameworks that make money from JavaScript server deployments are naturally inclined to prioritize differently.
