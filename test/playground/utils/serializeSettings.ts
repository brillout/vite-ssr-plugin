import { expect as expect } from '@brillout/test-e2e'
import { Config, PageContext } from 'vike/types'
import { isBrowser } from './isBrowser'

const START_MARKER = '===CONFIG:START==='
const END_MARKER = '===CONFIG:END==='
const EXTRACT_REGEX = RegExp(START_MARKER + '(.*)' + END_MARKER)

/**
 * Serializes the specified keys of {@link PageContext#config} and wraps the resulting JSON
 * in known start and end markers so that it can be later extracted from the resulting HTML
 * via {@link extractSerializedSettings} without knowing its exact position on the page.
 */
export function serializeSettings(pageContext: PageContext, keys: (string & keyof Config)[]) {
  let obj: Record<string, any> = { isBrowser }
  for (const key of keys) {
    obj[key] = valueOrType(pageContext.config[key])
  }
  return START_MARKER + JSON.stringify(obj) + END_MARKER
}

export function valueOrType(value: any) {
  if (value === undefined) {
    return 'undefined'
  }
  if (value === null) {
    return 'null'
  }
  return value
}

/**
 * Extracts and deserialized the config settings that were embedded into a page via {@link serializeSettings}.
 *
 * @param text The text that contains the serialized settings.
 * @param decodeHtmlEntities Whether to decode any HTML entities like `&quot;` before deserializing the JSON.
 * @returns
 */
export function extractSerializedSettings(
  text: string | null | undefined,
  options?: { expect?: { isBrowser?: boolean }; decodeHtmlEntities?: boolean }
): Record<string, any> {
  expect(text).to.not.be.null.and.to.not.be.undefined
  let jsonText = text!.match(EXTRACT_REGEX)?.[1]
  expect(jsonText).to.not.be.null.and.to.not.be.undefined
  if (options?.decodeHtmlEntities !== false) {
    // We only need to support the HTML entities that will be generated by React auto-escaping here
    // (as defined by https://github.com/facebook/react/blob/372ec00c0384cd2089651154ea7c67693ee3f2a5/packages/react-dom/src/__tests__/escapeTextForBrowser-test.js#L22-L45))
    // so we keep this basic instead of using a dedicated HTML entity encoding/decoding library.
    jsonText = jsonText!
      .replace(/&quot;/g, '"')
      .replace(/&#x27;/g, "'")
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&amp;/g, '&')
  }
  let parsed = JSON.parse(jsonText!)
  if (typeof options?.expect?.isBrowser !== 'undefined') {
    expect(typeof parsed).toBe('object')
    expect((parsed as Partial<Record<string, any>>).isBrowser).toBe(options.expect.isBrowser)
  }
  return parsed
}
